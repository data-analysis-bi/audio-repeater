<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Repeater App</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 20px auto; padding: 20px; }
        input, button { margin: 10px 0; display: block; }
        #download { display: none; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Audio Repeater</h1>
    <p>Upload an audio file, enter the number of times to repeat it, and click "Repeat" to generate a single repeated audio file for download.</p>
    
    <input type="file" id="audioFile" accept="audio/*">
    <input type="number" id="repeats" min="1" placeholder="Number of repeats (e.g., 5)">
    <button onclick="repeatAudio()">Repeat Audio</button>
    <div id="status" style="color: #666; min-height: 1.5em;"></div>
    <a id="download">Download Repeated Audio</a>

    <script>
        async function repeatAudio() {
            const fileInput = document.getElementById('audioFile');
            const repeatsInput = document.getElementById('repeats');
            const downloadLink = document.getElementById('download');

            const file = fileInput.files[0];
            const repeats = parseInt(repeatsInput.value);
            document.getElementById('status')?.innerText = 'Processing... please wait';

            if (!file || isNaN(repeats) || repeats < 1) {
                alert('Please upload an audio file and enter a valid number of repeats (at least 1).');
                return;
            }

            try {
    const arrayBuffer = await file.arrayBuffer();

    // We need a temporary AudioContext just to decode
    const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
    const originalBuffer = await tempCtx.decodeAudioData(arrayBuffer);

    // Now create OfflineAudioContext with the final size
    const offlineCtx = new OfflineAudioContext(
        originalBuffer.numberOfChannels,
        originalBuffer.length * repeats,
        originalBuffer.sampleRate
    );

    const source = offlineCtx.createBufferSource();
    source.buffer = originalBuffer;
    source.loop = true;
    source.connect(offlineCtx.destination);

    // Play exactly the number of loops we want
    source.start(0);
    source.stop(originalBuffer.duration * repeats);

    // This renders very quickly (native speed)
    const renderedBuffer = await offlineCtx.startRendering();
    document.getElementById('status')?.innerText = 'Done! Ready to download â†“';

    // Convert to downloadable WAV
    const wavBlob = audioBufferToWav(renderedBuffer);

    const url = URL.createObjectURL(wavBlob);
    downloadLink.href = url;
    downloadLink.download = 'repeated_audio.wav';
    downloadLink.style.display = 'block';
    downloadLink.textContent = 'Download Repeated Audio (WAV)';

} catch (error) {
    console.error(error);
    alert('Error: ' + (error.message || 'Could not process the audio file. Try another file or smaller repeat count.'));
}

        // Function to convert AudioBuffer to WAV Blob
        function audioBufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = buffer.length * numOfChan * 2 + 44; // 2 bytes per sample (16-bit)
            const wavBuffer = new ArrayBuffer(length);
            const view = new DataView(wavBuffer);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + buffer.length * numOfChan * 2, true); // ChunkSize
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (PCM)
            view.setUint16(20, 1, true); // AudioFormat (PCM)
            view.setUint16(22, numOfChan, true); // NumChannels
            view.setUint32(24, buffer.sampleRate, true); // SampleRate
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true); // ByteRate
            view.setUint16(32, numOfChan * 2, true); // BlockAlign
            view.setUint16(34, 16, true); // BitsPerSample
            writeString(view, 36, 'data');
            view.setUint32(40, buffer.length * numOfChan * 2, true); // Subchunk2Size

            // Write interleaved data (16-bit signed integers)
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return new Blob([wavBuffer], { type: 'audio/wav' });
        }

        // Helper to write string to DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
